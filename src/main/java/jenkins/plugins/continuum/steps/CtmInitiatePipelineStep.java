/*
 * Copyright 2017 CollabNet, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jenkins.plugins.continuum.steps;

import static org.apache.commons.lang.StringUtils.isBlank;

import java.io.IOException;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

import javax.annotation.Nonnull;

import org.jenkinsci.plugins.workflow.steps.StepContext;
import org.jenkinsci.plugins.workflow.steps.StepExecution;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.DataBoundSetter;
import org.kohsuke.stapler.QueryParameter;

import hudson.EnvVars;
import hudson.Extension;
import hudson.util.FormValidation;
import jenkins.plugins.continuum.ContinuumConstants;
import jenkins.plugins.continuum.InitiatePipelineInputBuilder;
import jenkins.plugins.continuum.actions.PipelineInitiatedAction;
import net.sf.json.JSONObject;

/**
 * Step for Continuum initiate-pipeline command
 */
public class CtmInitiatePipelineStep extends CtmCommandStep {

    /** The continuum project. */
    @DataBoundSetter public String project;

    /** The continuum definition. */
    @DataBoundSetter public String definition;

    /** The descriptive label of a continuum group to summarize multiple instances of this definition/project. */
    @DataBoundSetter public String group;

    /** An explicit name for the unique pipeline instance (Autogenerated if omitted.) */
    @DataBoundSetter public String instanceName;

    /** Comma-separated list of environment variables whose values to be included as details. */
    @DataBoundSetter public String environmentVariables;

    @DataBoundConstructor
    public CtmInitiatePipelineStep(String serverUrl) {
        super(serverUrl);
    }

    @Override
    public StepExecution start(StepContext context) throws Exception {
        CtmInitiatePipelineStepExecution execution = new CtmInitiatePipelineStepExecution(this, context);
        return execution;
    }

    @Extension
    public static class DescriptorImpl extends CtmCommandStepDescriptor {

        @Override
        public String getFunctionName() {
            return "ctmInitiatePipeline";
        }

        @Override
        public String getDisplayName() {
            return "Initiate a Continuum Pipeline Definition with matching 'key' information.";
        }

        /**
         * Validates that the user provided a project name.
         *
         * @param project
         *            the project name provided by the user
         * @return whether or not the validation succeeded
         */
        public FormValidation doCheckProject(@QueryParameter String project) {
            return FormValidation.validateRequired(project);
        }

        /**
         * Validates that the user provided continuum group.
         *
         * @param group
         *            the group provided by the user
         * @return whether or not the validation succeeded
         */
        public FormValidation doCheckGroup(@QueryParameter String group) {
            return FormValidation.validateRequired(group);
        }

        /**
         * Validates that the user provided continuum pipeline definition.
         *
         * @param definition
         *            the definition provided by the user
         * @return whether or not the validation succeeded
         */
        public FormValidation doCheckDefinition(@QueryParameter String definition) {
            return FormValidation.validateRequired(definition);
        }
    }

    public static class CtmInitiatePipelineStepExecution extends CtmCommandStepExecution<CtmInitiatePipelineStep> {
        private static final long serialVersionUID = 1L;
        private static final Logger logger = Logger.getLogger(CtmInitiatePipelineStepExecution.class.getName());

        /** Message for invalid continuum project name */
        public static String LOG_MESSAGE_INVALID_PROJECT = "The continuum project name is missing.";

        /** Message for invalid continuum group */
        public static String LOG_MESSAGE_INVALID_GROUP = "The continuum pipeline group label is missing.";

        /** Message for invalid continuum pipeline definition */
        public static String LOG_MESSAGE_INVALID_DEFINITION = "The definition for continuum pipeline is missing.";

        public CtmInitiatePipelineStepExecution(final CtmInitiatePipelineStep step, @Nonnull final StepContext ctx)
                throws IOException, InterruptedException {
            super(step, ctx);
        }

        @Override
        protected String getCommandName() {
            return ContinuumConstants.COMMAND_NAME__INITIATE_PIPELINE;
        }

        @Override
        protected Void run() throws Exception {
            PrintStream consoleLogger = this.listener.getLogger();
            String serverUrl = getServerUrl();
            if (isBlank(serverUrl)) {
                markUnstable(consoleLogger, LOG_MESSAGE_INVALID_URL);
                return null;
            }

            String prj = this.step.project;
            if (isBlank(prj)) {
                markUnstable(consoleLogger, LOG_MESSAGE_INVALID_PROJECT);
                return null;
            }

            String grp = this.step.group;
            if (isBlank(grp)) {
                markUnstable(consoleLogger, LOG_MESSAGE_INVALID_GROUP);
                return null;
            }

            String def = this.step.definition;
            if (isBlank(def)) {
                markUnstable(consoleLogger, LOG_MESSAGE_INVALID_DEFINITION);
                return null;
            }
            try {
                initialize();
                Map<String, Object> commandParams = new HashMap<String, Object>();
                commandParams.put(ContinuumConstants.COMMAND_PARAMETER__PROJECT, step.project);
                commandParams.put(ContinuumConstants.COMMAND_PARAMETER__GROUP, step.group);
                commandParams.put(ContinuumConstants.COMMAND_PARAMETER__DEFINITION, step.definition);
                if (!isBlank(this.step.instanceName)) {
                    commandParams.put(ContinuumConstants.COMMAND_PARAMETER__INSTANCE_NAME, step.instanceName);
                }
                try {
                    JSONObject details = getDetails();
                    if (details != null) {
                        commandParams.put(ContinuumConstants.COMMAND_PARAMETER__DETAILS, details);
                    }
                }
                catch (Exception detailExc) {
                    log("Failed to include details: ", consoleLogger);
                    detailExc.printStackTrace(consoleLogger);
                }
                String json = converter.toContinuumAPI(run, commandParams);
                String pipelineId = executeCommandAndExtractPipelineId(commandParams);
                if (!isBlank(pipelineId)) {
                    PipelineInitiatedAction pia = this.run.getAction(PipelineInitiatedAction.class);
                    if (pia != null) {
                        pia.addPipelineId(serverUrl, pipelineId);
                    }
                    else {
                        this.run.addAction(new PipelineInitiatedAction(serverUrl, pipelineId));
                    }
                    log("Initiated pipeline: " + pipelineId, consoleLogger);
                }
                else {
                    log("No pipeline id. Input: " + json, consoleLogger);
                }
                
            } catch (IllegalStateException ise) {
                markUnstable(consoleLogger,
                        "Can't initiate pipeline: this step needs a Jenkins URL " +
                        "(go to Manage Jenkins > Configure System; click Save)");
                ise.printStackTrace(consoleLogger);

            } catch (Exception e) {
                markUnstable(consoleLogger, e.getMessage());
                log("Can't initiate pipeline, details below", consoleLogger);
                e.printStackTrace(consoleLogger);
            }
            return null;
        }

        protected String executeCommandAndExtractPipelineId(Map<String, Object> commandParams) throws Exception {
            String commandResult = executeCommand(commandParams);
            if (!isBlank(commandResult)) {
                JSONObject commandResultObject = JSONObject.fromObject(commandResult);
                if (commandResultObject != null) {
                    if (commandResultObject.has("Response")) {
                        JSONObject respObj = commandResultObject.getJSONObject("Response");
                        if (respObj != null && respObj.has("_id")) {
                            return respObj.getString("_id");
                        }
                    }
                    else {
                        // TODO try to parse error
                    }
                }
            }
            return null;
        }

        /**
         * Marks the current run as unstable and logs a message.
         * 
         * @param consoleLogger
         *            the logger to log to
         * @param message
         *            the message to log
         */
        private void markUnstable(PrintStream consoleLogger, String message) {
            log(message, consoleLogger);
            logger.warning(message);
            markUnstable();
        }
        
        /**
         * Jenkins (un)helpfully wipes out any initialization done in constructors
         * or class definitions before executing this #perform method. So we need to
         * initialize it in case it wasn't already.
         */
        private void initialize() {
            if (this.converter == null) {
                this.converter = new InitiatePipelineInputBuilder();
            }
        }

        private JSONObject getDetails() throws Exception{
            if (!isBlank(this.step.environmentVariables)) {
                String[] subset = this.step.environmentVariables.trim().split("\\s*,\\s*");
                if (subset.length == 1 && "*".equals(subset[0])) {
                	subset = null;
                }
                EnvVars eVars = getEnvVars(subset, true /* replaceDots */);
                JSONObject details = JSONObject.fromObject(eVars);
                if (details != null && !details.isEmpty()) {
                    return new JSONObject()
                            .element("automation", new JSONObject()
                                    .element("version", "1.0")
                                    .element("type", "jenkins")
                                    .element("environmentVariables", details)
                            );
                }
            }
            return null;
        }
    }
}
